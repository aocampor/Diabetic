// Class: ReadBDTMitFisher
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTMitFisher
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 6.02/08       [393736]
Creator        : aocampor
Date           : Sat May 16 19:25:58 2015
Host           : Linux DaMachine 3.16.0-34-generic #45-Ubuntu SMP Mon Mar 23 17:21:27 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/aocampor/GIT/Diabetic/train_tree
Training events: 6000
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 5
Red                           Red                           Red                           Red                                                             'F'    [0,255]
Green                         Green                         Green                         Expression 2                                                    'F'    [0,252]
Blue                          Blue                          Blue                          Variable 3                    units                             'F'    [0,233]
PixelX                        PixelX                        PixelX                        Variable 4                    units                             'F'    [36,548]
PixelY                        PixelY                        PixelY                        Variable 5                    units                             'F'    [0,388]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTMitFisherNode
   
#ifndef BDTMitFisherNode__def
#define BDTMitFisherNode__def
   
class BDTMitFisherNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTMitFisherNode ( BDTMitFisherNode* left,BDTMitFisherNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
   }

   virtual ~BDTMitFisherNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTMitFisherNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTMitFisherNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTMitFisherNode*   fLeft;     // pointer to the left daughter node
   BDTMitFisherNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTMitFisherNode::~BDTMitFisherNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTMitFisherNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] > fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTMitFisherNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTMitFisher : public IClassifierReader {

 public:

   // constructor
   ReadBDTMitFisher( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTMitFisher" ),
        fNvars( 5 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "Red", "Green", "Blue", "PixelX", "PixelY" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTMitFisher() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[5];
   double fVmax[5];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[5];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTMitFisherNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTMitFisher::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTMitFisherNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTMitFisherNode*)current->GetRight();
         else current=(BDTMitFisherNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDTMitFisher::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.935901088450796);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.961611,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47541,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 164.714, 0, 0, 0.922809,-99) , 
NN(
0, 
0, 
6, 0.00197961, -0.0167368, 0.0290167, 0, 0, -0.0801085, -1, 0.0719772, 0, 1, 0.610883,-99) , 
0, 0, 0, 0, 0, 0, 0, 2, 44.1905, 0, 0, 0.829813,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.562069,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.179081,-99) , 
6, -0.00471676, 0.00924013, -0.000650366, 0, 0, -0.0889875, 5, -0.0116789, 0, 0, 0.299674,-99) , 
NN(
0, 
0, 
6, -0.00386618, 0.0136557, -0.0122232, 0, 0, 0.101289, -1, 0.0413116, 0, -1, 0.00717439,-99) , 
6, -0.021018, 0.0565092, -0.0405105, 0, 0, 0.261379, 5, 0.026071, 0, 0, 0.105745,-99) , 
6, -0.0251678, 0.0771667, -0.0542473, 0, 0, -0.509877, 5, -0.0721885, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.763713);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 185.286, 0, 1, 0.907176,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.758074,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.342752,-99) , 
6, -0.00189269, -0.0103664, 0.0380387, 0, 0, -0.510504, 5, 0.062619, 0, 0, 0.475352,-99) , 
0, 0, 0, 0, 0, 0, 0, 2, 51.4286, 0, 0, 0.682242,-99) , 
NN(
0, 
0, 
6, -0.0161209, 0.0449314, -0.036162, 0, 0, 0.337683, -1, 0.0931263, 0, -1, 0.137995,-99) , 
6, -0.0169743, 0.051305, -0.0360846, 0, 0, -0.344932, 5, -0.110733, 0, 0, 0.459976,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.621697);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.697771,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.157985,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 110.286, 0, 0, 0.662018,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.615292,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 54.0952, 1, -1, 0.0102306,-99) , 
6, -0.0136498, 0.0401855, -0.030713, 0, 0, -0.0874482, 5, -0.283061, 0, 0, 0.503954,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.430043);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.932493,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.412646,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 187.667, 0, 0, 0.836774,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.500866,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.144813,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 377.333, 1, 0, 0.448331,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 94.4762, 0, 0, 0.542666,-99) , 
NN(
0, 
0, 
6, -0.0100805, 0.0289063, -0.0241138, 0, 0, 0.323654, -1, 0.0324303, 0, -1, 0.0583257,-99) , 
6, -0.0144025, 0.0380986, -0.0274419, 0, 0, -0.0209144, 5, -0.173424, 0, 0, 0.42953,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.499388);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.919267,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.311985,-99) , 
6, -0.00712827, 0.0267828, -0.0259352, 0, 0, 0.0313322, 5, -0.111619, 0, 0, 0.804885,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 426.095, 1, -1, 0.370703,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 94.4762, 0, 0, 0.465654,-99) , 
NN(
0, 
0, 
6, -0.00762768, 0.0258713, -0.0239203, 0, 0, 0.248666, -1, 0.0128045, 0, -1, 0.0727718,-99) , 
6, -0.0126093, 0.0316256, -0.0219906, 0, 0, 0.00519263, 5, -0.171377, 0, 0, 0.38897,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.33424);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.973713,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.432327,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 187.667, 0, 0, 0.840288,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.523669,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.497209,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 94.7143, 0, 0, 0.561172,-99) , 
NN(
0, 
0, 
6, -0.0121541, 0.0353916, -0.030913, 0, 0, 0.435766, -1, -0.0300688, 0, -1, 0.137508,-99) , 
6, -0.0118471, 0.0279749, -0.0197561, 0, 0, 0.105393, 5, -0.123133, 0, 0, 0.473327,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.32684);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 226.524, 0, 1, 0.964003,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.515297,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.134899,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 109.143, 0, 0, 0.473763,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 139.905, 0, 0, 0.553767,-99) , 
NN(
0, 
0, 
6, -0.0139212, 0.0273813, -0.0190349, 0, 0, 0.481293, -1, -0.165452, 0, -1, 0.301756,-99) , 
6, -0.00993471, 0.0229901, -0.0157038, 0, 0, 0.0761976, 5, 0.00906315, 0, 0, 0.432703,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.249816);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.875813,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.454661,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 145.714, 0, 0, 0.490251,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
6, -0.00645001, 0.0140473, -0.00996318, 0, 0, 0.107241, 5, -0.185375, 0, 0, 0.462122,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.433834,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.225683);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.954117,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.48801,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 187.667, 0, 0, 0.824538,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.505928,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.475015,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 94.7143, 0, 0, 0.528096,-99) , 
NN(
0, 
0, 
6, -0.0135539, 0.0400962, -0.038331, 0, -0.00164206, 1.02459, -1, 0.0652955, 0, -1, 0.141798,-99) , 
6, -0.00616867, 0.0137928, -0.00986072, 0, 0, 0.0900122, 5, -0.110002, 0, 0, 0.486255,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.223348);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.537815,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.201394,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 47.4286, 0, 0, 0.49767,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.474301,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.450429,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.334241);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.850934,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.135487,-99) , 
6, -0.00980026, 0.0290065, -0.0254072, 0, 0, 0.123629, 5, -0.157837, 0, 0, 0.692325,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 332.571, 1, -1, 0.391485,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 94.4762, 0, 0, 0.43567,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
6, -0.00585978, 0.0118337, -0.00770943, 0, 0, 0.104392, 5, -0.153948, 0, 0, 0.415322,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.198909);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.544123,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.523306,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0685419,-99) , 
6, -0.00502876, 0.00813744, -0.00568926, 0, 0, 0.203313, 5, -0.136833, 0, 0, 0.499119,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.478945,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.259256);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.604546,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.404421,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 109.286, 1, 0, 0.473931,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.457737,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.440739,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.114398);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510644,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 91.7143, 0, 0, 0.493444,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.478318,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.462323,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.131435);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
6, -0.00543675, 0.011002, -0.00731146, 0, 0, 0.105076, -1, -0.150204, 0, -1, 0.481308,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.563584,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0920778,-99) , 
6, 0.00207191, -0.0257949, 0.0263361, 0, 0, 0.427262, 5, 0.0133826, 0, 0, 0.231476,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 47.4286, 0, 0, 0.453144,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.438762,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.147654);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.524462,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 91.7143, 0, 0, 0.507738,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.493366,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 24, 0, -1, 0.178809,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.469192,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.117722);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 332.571, 1, -1, 0.441409,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.145095);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.903832,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.479239,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 145.714, 0, 0, 0.503703,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 85.1429, 1, -1, 0.169081,-99) , 
6, -0.00458858, 0.00852697, -0.00546555, 0, 0, 0.112739, 5, -0.105357, 0, 0, 0.485345,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.470603,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.214198);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.643638,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.462378,-99) , 
6, -0.00148991, 0.000345638, 0.00282943, 0, 0, 0.0141854, 5, -0.0035771, 0, 0, 0.536919,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 95.0476, 1, -1, 0.185908,-99) , 
6, -0.00443828, 0.0078518, -0.00506971, 0, 0, 0.129734, 5, -0.100199, 0, 0, 0.517763,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.503021,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.377971);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.762871,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.451735,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 211.333, 0, 0, 0.640213,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.727391,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.365435,-99) , 
6, 0.00305827, 0.0137837, -0.0445107, 0, 0, 0.278952, 5, 0.0714477, 0, 0, 0.44886,-99) , 
6, -4.91947e-05, -0.00231903, 0.00519902, 0, 0, -0.0456157, 5, -0.0116025, 0, 0, 0.539276,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.00927396,-99) , 
6, -0.00258694, 0.00670542, -0.00608449, 0, 0, 0.0554887, 5, -0.110145, 0, 0, 0.516437,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.286102);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.603234,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.245403,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.580172,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 426.095, 1, 0, 0.564607,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.048174,-99) , 
6, -0.00241539, 0.00841102, -0.00821932, 0, 0, 0.00205831, 5, -0.130172, 0, 0, 0.539607,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.222123);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.56712,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.36287,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 328.571, 1, 0, 0.521656,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.119363,-99) , 
6, -0.0029862, 0.00744306, -0.00639604, 0, 0, 0.0558476, 5, -0.092676, 0, 0, 0.502105,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.487038,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.109958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.509542,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 422.857, 1, 0, 0.494793,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.197296,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 109.143, 0, 0, 0.475064,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.462071,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.25586);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.560298,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.317752,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 133.524, 0, 0, 0.504702,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.519936,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.199148,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 256.714, 0, 0, 0.351705,-99) , 
6, -0.00315059, 0.00547334, -0.00359781, 0, 0, 0.0984508, 5, -0.0140361, 0, 0, 0.452508,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 332.571, 1, 0, 0.440741,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.245009);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.836692,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416052,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 156.143, 0, 0, 0.691762,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 328.571, 1, -1, 0.407421,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 139.905, 0, 0, 0.43359,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0946468,-99) , 
6, -0.00276539, 0.00599131, -0.00443931, 0, 0, 0.0532294, 5, -0.0718197, 0, 0, 0.418729,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.21154);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.56298,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.392074,-99) , 
6, -0.00666053, 0.00951745, -0.00526952, 0, 0, 0.269077, 5, -0.0308205, 0, 0, 0.508064,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.143658,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 105.524, 0, 0, 0.490777,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 415.905, 1, -1, 0.204359,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 401.714, 1, 0, 0.471821,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.237642);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.559261,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.366089,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 328.571, 1, 0, 0.507896,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.107647,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 324.762, 1, 0, 0.490388,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.560797,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.146241,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 238.667, 0, 0, 0.261821,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 55.4286, 0, 0, 0.460016,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.118238);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 314.095, 1, -1, 0.441155,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.140779);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.524706,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.194011,-99) , 
6, -0.00259328, 0.00395611, -0.00261434, 0, 0, 0.11046, 5, -0.063601, 0, 0, 0.512536,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 112.667, 1, -1, 0.25394,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 44.8571, 0, 0, 0.487648,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 67.5714, 1, -1, 0.204694,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 314.095, 1, 0, 0.470475,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.384623);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
6, -0.0204417, 0.0638883, -0.0483051, 0, 0, -0.639979, -1, 0.0958951, 0, 1, 0.854476,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.600415,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.369396,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 240.19, 0, 0, 0.446675,-99) , 
6, -0.0111039, 0.0267119, -0.0167601, 0, 0, 0.0177491, 5, 0.127065, 0, 0, 0.498897,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.946524,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.45554,-99) , 
6, 0.0566953, -0.113172, 0.0566687, 0, 0, -0.0644655, 5, 0.118795, 0, 0, 0.636373,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 144, 0, -1, 0.254008,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 75.0476, 1, 0, 0.376764,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 182.286, 0, 0, 0.447637,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0951015);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 22.1905, 1, 1, 0.518729,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.247236,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 29.9048, 0, 0, 0.504279,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 61.4286, 1, -1, 0.196361,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 314.095, 1, 0, 0.485946,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.109025);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.721563,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 85, 0, -1, 0.470016,-99) , 
0, 0, 0, 0, 0, 0, 0, 2, 22.1905, 1, 0, 0.483001,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 61.4286, 1, -1, 0.211803,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 314.095, 1, 0, 0.467248,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.128451);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.533036,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.308751,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 109.143, 0, 0, 0.519704,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.277961,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 29.9048, 0, 0, 0.507451,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 61.4286, 1, -1, 0.230575,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 314.095, 1, 0, 0.491781,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.103335);
  fForest.push_back( 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.702277,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 314.095, 1, -1, 0.456796,-99) , 
0, 0, 0, 0, 0, 0, 0, 2, 22.1905, 1, 0, 0.469574,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.456031);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.908389,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.402815,-99) , 
6, -0.0125631, 0.0573862, -0.054552, 0, 0, -0.107302, 5, -0.0115275, 0, 0, 0.692356,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.677899,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.285446,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 148.429, 0, 0, 0.430388,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 234.143, 0, 0, 0.558645,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.723434,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.371475,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 108.667, 1, 0, 0.509355,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.530777,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0548861,-99) , 
6, 0.0173103, -0.0588698, 0.0227622, -0.00918098, 0, 4.25384, 5, -0.0867006, 0, 0, 0.189621,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 328.571, 1, 0, 0.447592,-99) , 
0, 0, 0, 0, 0, 0, 0, 2, 44.381, 0, 0, 0.492659,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.2074);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.583119,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.406873,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 339.429, 1, 0, 0.545166,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.29246,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 109.143, 0, 0, 0.531114,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 61.4286, 1, -1, 0.226554,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 314.095, 1, 0, 0.514044,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.176383);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
6, -0.0343764, 0.0360698, -0.00517776, 0, 0, 0.938197, -1, 0.0387035, 0, 1, 0.777269,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.61834,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.325307,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 352.952, 1, 0, 0.474376,-99) , 
6, 0.00129257, 0.00119925, -0.00149001, 0, 0, -0.104366, 5, 0.0227173, 0, 0, 0.608472,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.515464,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.195978,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 308.952, 1, 0, 0.494063,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.182475,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 55.4286, 0, 0, 0.466338,-99) , 
6, -0.00210108, 0.0020846, -0.000135149, 0, 0, 0.083444, 5, 0.015856, 0, 0, 0.493288,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.186619);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 350.857, 1, 1, 0.696362,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.365266,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 133.524, 0, 0, 0.611228,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.527779,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.409911,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 170.714, 1, 0, 0.4568,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.14437,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.442009,-99) , 
6, -0.00243154, 0.00215365, -8.65265e-05, 0, 0, 0.113251, 5, 0.0288612, 0, 0, 0.464013,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.280229);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
6, -0.0143604, 0.0414408, -0.0302606, 0, 0, -0.306263, -1, 0.114549, 0, 1, 0.782329,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 410, 1, -1, 0.453124,-99) , 
6, -0.00965093, 0.0198049, -0.011348, 0, 0, 0.121052, 5, 0.0907744, 0, 0, 0.504574,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.888628,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.326597,-99) , 
6, 0.0665393, -0.127156, 0.0633723, 0, 0, -0.172191, 5, -0.0106011, 0, 0, 0.624732,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 126.143, 0, -1, 0.256328,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 76.2857, 1, 0, 0.390709,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 157.905, 0, 0, 0.470361,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.261348);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
6, -0.0108325, 0.0184422, -0.00928989, 0, 0, 0.281345, -1, 0.113201, 0, 1, 0.591559,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.214353,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 408.952, 1, 0, 0.565612,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.577784,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.16911,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 268.762, 1, 0, 0.509837,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.133094,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 74.7143, 0, 0, 0.447022,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 182.286, 0, 0, 0.51731,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.224718);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.859322,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.621081,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.439488,-99) , 
6, -0.00549857, 0.0120627, -0.00675831, 0, 0, 0.014903, 5, 0.044023, 0, 0, 0.481685,-99) , 
0, 0, 0, 0, 0, 0, 0, 2, 22.1905, 1, 0, 0.493917,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.634662,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 188.667, 0, -1, 0.127286,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 76.2857, 1, 0, 0.347951,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 133.524, 0, 0, 0.472896,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.403765);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.703732,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.188397,-99) , 
6, -0.0106708, 0.0140897, 0.00123504, -0.0013787, 0, 0.41833, 5, -0.14972, 0, 0, 0.596854,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.571628,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.313611,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 132.143, 1, 0, 0.473095,-99) , 
6, -0.00589087, 0.0113811, -0.0067802, 0, 0, 0.124911, 5, 0.000611982, 0, 0, 0.539803,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.839338,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.318234,-99) , 
6, 0.0604055, -0.114972, 0.0577997, 0, 0, -0.185621, 5, -0.0251656, 0, 0, 0.588972,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 126.143, 0, -1, 0.28279,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 76.2857, 1, 0, 0.38907,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 157.905, 0, 0, 0.497124,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0812245);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.938609,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.498432,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 103.19, 0, 0, 0.511781,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.190778,-99) , 
6, -0.00127248, 0.0024996, -0.00254338, 0, 0, 0.0695282, 5, -0.0459176, 0, 0, 0.4984,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50583,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.108555,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 24, 0, 0, 0.274925,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.483606,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.147924);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.623674,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.482354,-99) , 
6, -0.00023872, -0.00180813, 0.00440356, 0, 0, -0.028202, 5, 0.00018456, 0, 0, 0.529521,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.0825543,-99) , 
6, -0.00116756, 0.00223042, -0.00244899, 0, 0, 0.0738664, 5, -0.0556343, 0, 0, 0.517554,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 24, 0, -1, 0.274003,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.50168,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.148584);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.551516,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.342798,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 109.143, 0, 0, 0.541588,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.214589,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 321.143, 1, 0, 0.530772,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.52249,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.132799,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 24, 0, 0, 0.30439,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.516353,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.104201);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 146, 0, 1, 0.515808,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.238186,-99) , 
6, -0.00194699, 0.00537673, -0.00592268, 0, 0, 0.078916, 5, -0.0999347, 0, 0, 0.50456,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.672648,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.202837,-99) , 
6, 0.0132844, -0.0531488, 0.0456932, 0, 0, 0.412669, 5, 0.0904247, 0, 0, 0.351016,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 55.4286, 0, 0, 0.48727,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.135767);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
6, 0, 0.02002, -0.0163644, 0, 0, -0.993591, -1, -0.0174426, 0, 1, 0.734158,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508073,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.379583,-99) , 
6, 3.81871e-05, -0.00351258, 0.00300798, 0, 0, 0.12518, 5, -0.0190194, 0, 0, 0.458754,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 142.476, 0, 0, 0.474032,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.212747,-99) , 
6, -0.000813656, 0.00113782, -0.00196645, 0, 0, 0.0945406, 5, -0.0651678, 0, 0, 0.466949,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.116499);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.790083,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 304.19, 1, -1, 0.460064,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 105.238, 0, 0, 0.469693,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.100792,-99) , 
6, -0.00154814, 0.00413191, -0.00412193, 0, 0, 0.0464071, 5, -0.0720053, 0, 0, 0.458423,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.123724);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.742929,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.479054,-99) , 
0, 0, 0, 0, 0, 0, 0, 3, 133.524, 0, 0, 0.647977,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508414,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.327318,-99) , 
0, 0, 0, 0, 0, 0, 0, 1, 63.1429, 0, 0, 0.474612,-99) , 
6, -0.000142896, -0.000272553, 0.00106286, 0, 0, -0.00937203, 5, -0.00705783, 1, 0, 0.49519,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.217155,-99) , 
6, -0.00142207, 0.00386708, -0.00413655, 0, 0, 0.0529276, 5, -0.0714779, 0, 0, 0.485773,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.109611);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.649383,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.475397,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 139.905, 0, 0, 0.490634,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.211514,-99) , 
6, -0.00257065, 0.00577557, -0.0054876, 0, 0, 0.0990913, 5, -0.0839275, 0, 0, 0.480822,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, -1, 24, 0, -1, 0.290073,-99) , 
0, 0, 0, 0, 0, 0, 0, 4, 36.9524, 0, 0, 0.469107,-99)    );
   return;
};
 
// Clean up
inline void ReadBDTMitFisher::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTMitFisher::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
